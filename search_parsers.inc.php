<?php

$arxiv_keyword_ref = array(
	'astro-ph' => 'Astrophysics',
	'astro-ph.CO' => 'Cosmology and Nongalactic Astrophysics',
	'astro-ph.EP' => 'Earth and Planetary Astrophysics',
	'astro-ph.GA' => 'Astrophysics of Galaxies',
	'astro-ph.HE' => 'High Energy Astrophysical Phenomena',
	'astro-ph.IM' => 'Instrumentation and Methods for Astrophysics',
	'astro-ph.SR' => 'Solar and Stellar Astrophysics',
	'cond-mat.dis-nn' => 'Disordered Systems and Neural Networks',
	'cond-mat.mes-hall' => 'Mesoscale and Nanoscale Physics',
	'cond-mat.mtrl-sci' => 'Materials Science',
	'cond-mat.other' => 'Other Condensed Matter',
	'cond-mat.quant-gas' => 'Quantum Gases',
	'cond-mat.soft' => 'Soft Condensed Matter',
	'cond-mat.stat-mech' => 'Statistical Mechanics',
	'cond-mat.str-el' => 'Strongly Correlated Electrons',
	'cond-mat.supr-con' => 'Superconductivity',
	'cs.AI' => 'Artificial Intelligence',
	'cs.AR' => 'Hardware Architecture',
	'cs.CC' => 'Computational Complexity',
	'cs.CE' => 'Computational Engineering, Finance, and Science',
	'cs.CG' => 'Computational Geometry',
	'cs.CL' => 'Computation and Language',
	'cs.CR' => 'Cryptography and Security',
	'cs.CV' => 'Computer Vision and Pattern Recognition',
	'cs.CY' => 'Computers and Society',
	'cs.DB' => 'Databases',
	'cs.DC' => 'Distributed, Parallel, and Cluster Computing',
	'cs.DL' => 'Digital Libraries',
	'cs.DM' => 'Discrete Mathematics',
	'cs.DS' => 'Data Structures and Algorithms',
	'cs.ET' => 'Emerging Technologies',
	'cs.FL' => 'Formal Languages and Automata Theory',
	'cs.GL' => 'General Literature',
	'cs.GR' => 'Graphics',
	'cs.GT' => 'Computer Science and Game Theory',
	'cs.HC' => 'Human-Computer Interaction',
	'cs.IR' => 'Information Retrieval',
	'cs.IT' => 'Information Theory',
	'cs.LG' => 'Learning',
	'cs.LO' => 'Logic in Computer Science',
	'cs.MA' => 'Multiagent Systems',
	'cs.MM' => 'Multimedia',
	'cs.MS' => 'Mathematical Software',
	'cs.NA' => 'Numerical Analysis',
	'cs.NE' => 'Neural and Evolutionary Computing',
	'cs.NI' => 'Networking and Internet Architecture',
	'cs.OH' => 'Other Computer Science',
	'cs.OS' => 'Operating Systems',
	'cs.PF' => 'Performance',
	'cs.PL' => 'Programming Languages',
	'cs.RO' => 'Robotics',
	'cs.SC' => 'Symbolic Computation',
	'cs.SD' => 'Sound',
	'cs.SE' => 'Software Engineering',
	'cs.SI' => 'Social and Information Networks',
	'cs.SY' => 'Systems and Control',
	'econ.EM' => 'Econometrics',
	'eess.AS' => 'Audio and Speech Processing',
	'eess.IV' => 'Image and Video Processing',
	'eess.SP' => 'Signal Processing',
	'gr-qc' => 'General Relativity and Quantum Cosmology',
	'hep-ex' => 'High Energy Physics - Experiment',
	'hep-lat' => 'High Energy Physics - Lattice',
	'hep-ph' => 'High Energy Physics - Phenomenology',
	'hep-th' => 'High Energy Physics - Theory',
	'math.AC' => 'Commutative Algebra',
	'math.AG' => 'Algebraic Geometry',
	'math.AP' => 'Analysis of PDEs',
	'math.AT' => 'Algebraic Topology',
	'math.CA' => 'Classical Analysis and ODEs',
	'math.CO' => 'Combinatorics',
	'math.CT' => 'Category Theory',
	'math.CV' => 'Complex Variables',
	'math.DG' => 'Differential Geometry',
	'math.DS' => 'Dynamical Systems',
	'math.FA' => 'Functional Analysis',
	'math.GM' => 'General Mathematics',
	'math.GN' => 'General Topology',
	'math.GR' => 'Group Theory',
	'math.GT' => 'Geometric Topology',
	'math.HO' => 'History and Overview',
	'math.IT' => 'Information Theory',
	'math.KT' => 'K-Theory and Homology',
	'math.LO' => 'Logic',
	'math.MG' => 'Metric Geometry',
	'math.MP' => 'Mathematical Physics',
	'math.NA' => 'Numerical Analysis',
	'math.NT' => 'Number Theory',
	'math.OA' => 'Operator Algebras',
	'math.OC' => 'Optimization and Control',
	'math.PR' => 'Probability',
	'math.QA' => 'Quantum Algebra',
	'math.RA' => 'Rings and Algebras',
	'math.RT' => 'Representation Theory',
	'math.SG' => 'Symplectic Geometry',
	'math.SP' => 'Spectral Theory',
	'math.ST' => 'Statistics Theory',
	'math-ph' => 'Mathematical Physics',
	'nlin.AO' => 'Adaptation and Self-Organizing Systems',
	'nlin.CD' => 'Chaotic Dynamics',
	'nlin.CG' => 'Cellular Automata and Lattice Gases',
	'nlin.PS' => 'Pattern Formation and Solitons',
	'nlin.SI' => 'Exactly Solvable and Integrable Systems',
	'nucl-ex' => 'Nuclear Experiment',
	'nucl-th' => 'Nuclear Theory',
	'physics.acc-ph' => 'Accelerator Physics',
	'physics.ao-ph' => 'Atmospheric and Oceanic Physics',
	'physics.app-ph' => 'Applied Physics',
	'physics.atm-clus' => 'Atomic and Molecular Clusters',
	'physics.atom-ph' => 'Atomic Physics',
	'physics.bio-ph' => 'Biological Physics',
	'physics.chem-ph' => 'Chemical Physics',
	'physics.class-ph' => 'Classical Physics',
	'physics.comp-ph' => 'Computational Physics',
	'physics.data-an' => 'Data Analysis, Statistics and Probability',
	'physics.ed-ph' => 'Physics Education',
	'physics.flu-dyn' => 'Fluid Dynamics',
	'physics.gen-ph' => 'General Physics',
	'physics.geo-ph' => 'Geophysics',
	'physics.hist-ph' => 'History and Philosophy of Physics',
	'physics.ins-det' => 'Instrumentation and Detectors',
	'physics.med-ph' => 'Medical Physics',
	'physics.optics' => 'Optics',
	'physics.plasm-ph' => 'Plasma Physics',
	'physics.pop-ph' => 'Popular Physics',
	'physics.soc-ph' => 'Physics and Society',
	'physics.space-ph' => 'Space Physics',
	'q-bio.BM' => 'Biomolecules',
	'q-bio.CB' => 'Cell Behavior',
	'q-bio.GN' => 'Genomics',
	'q-bio.MN' => 'Molecular Networks',
	'q-bio.NC' => 'Neurons and Cognition',
	'q-bio.OT' => 'Other Quantitative Biology',
	'q-bio.PE' => 'Populations and Evolution',
	'q-bio.QM' => 'Quantitative Methods',
	'q-bio.SC' => 'Subcellular Processes',
	'q-bio.TO' => 'Tissues and Organs',
	'q-fin.CP' => 'Computational Finance',
	'q-fin.EC' => 'Economics',
	'q-fin.GN' => 'General Finance',
	'q-fin.MF' => 'Mathematical Finance',
	'q-fin.PM' => 'Portfolio Management',
	'q-fin.PR' => 'Pricing of Securities',
	'q-fin.RM' => 'Risk Management',
	'q-fin.ST' => 'Statistical Finance',
	'q-fin.TR' => 'Trading and Market Microstructure',
	'quant-ph' => 'Quantum Physics',
	'stat.AP' => 'Applications',
	'stat.CO' => 'Computation',
	'stat.ME' => 'Methodology',
	'stat.ML' => 'Machine Learning',
	'stat.OT' => 'Other Statistics',
	'stat.TH' => 'Statistics Theory',
);

$month_ref = array(
	'01' => '01',
	'Jan' => '01',
	'January' => '01',
	'02' => '02',
	'Feb' => '02',
	'February' => '02',
	'03' => '03',
	'Mar' => '03',
	'March' => '03',
	'04' => '04',
	'Apr' => '04',
	'April' => '04',
	'05' => '05',
	'May' => '05',
	'06' => '06',
	'Jun' => '06',
	'June' => '06',
	'07' => '07',
	'Jul' => '07',
	'July' => '07',
	'08' => '08',
	'Aug' => '08',
	'August' => '08',
	'09' => '09',
	'Sept' => '09',
	'September' => '09',
	'Sep' => '09',
	'10' => '10',
	'Oct' => '10',
	'October' => '10',
	'11' => '11',
	'Nov' => '11',
	'November' => '11',
	'12' => '12',
	'Dec' => '12',
	'December' => '12'
);

$max_results = 50;

function arxiv_search($user_query,$field){

	global $month_ref;
	global $arxiv_keyword_ref; # dictionary with arXiv's keyword references

	$entry_count = 0; # will count the number of entries found

	$arxiv_entries = array(); # dictionary with the parsed entries

	$base_url = 'http://export.arxiv.org/api/query?';

	# Search parameters
	$start = 0;
	global $max_results;

	# Query construction
	$query = "search_query=$field:".preg_replace('/\s+/', '+', $user_query)."&start=$start&max_results=$max_results";

	$feed = file_get_contents($base_url.$query); # get xml from the api

	# parse entries from whole xml
	preg_match_all('/<entry>(.+?)<\/entry>/is', $feed, $entries,PREG_UNMATCHED_AS_NULL);

	if(empty($entries)){
		return arxiv_entries;
	}

	foreach ($entries[1] as $entry) {

		#print $entry."\n\n\n";
		$entry_count += 1;

		# parse each entry
		preg_match('/<id>(.+?)<\/id>/is', $entry, $link); # link
		preg_match('/<title>(.+?)<\/title>/is', $entry, $title); # title
		preg_match('/<summary>(.+?)<\/summary>/is', $entry, $abstract, PREG_UNMATCHED_AS_NULL); # abstract
		if(empty($abstract)){$abstract[1] = '';}
		preg_match_all('/<name>(.+?)<\/name>/is', $entry, $authors); # authors
		preg_match_all('/<category term="(.+?)" scheme=/is', $entry, $keywords_ref, PREG_UNMATCHED_AS_NULL); # keyword references
		if(empty($keywords_ref)){
			$keywords = '';
		}else{
			$keywords = array();
			foreach ($keywords_ref[1] as $ref) {
				if(array_key_exists($ref, $arxiv_keyword_ref)){
					$keywords[] = $arxiv_keyword_ref[$ref];
				}
			}
		}

		preg_match('/">(.+?)<\/arxiv:doi>/is', $entry, $doi, PREG_UNMATCHED_AS_NULL); # doi, if any
		if(empty($doi)){$doi[1] = '';}

		# construct entry dict
		$entry = array( 
			'title' => $title[1],
			'link' => $link[1],
			'doi' => $doi[1],
			'journal' => '',
			'abstract' => $abstract[1],
			'authors' => $authors[1],
			'keywords' => $keywords,
			'source' => 'arxiv',
 			'source_id' => $id[1],
			);
		
		# append to entries dict
		$arxiv_entries["entry$entry_count"] = $entry;
	}
	return $arxiv_entries;
}

function pubmed_search($user_query,$field){

	global $month_ref;
	
	$entry_count = 0; # will count the number of entries found

	$pubmed_entries = array(); # dictionary with the parsed entries

	$base_url_search = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?';

	$base_url_fetch = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?';

	# Search parameters 
	$database = 'pubmed';
	global $max_results;
	$tool = 'FreedMetrics';
	$email = 'freedmetrics@gmail.com';
	$history = 'y';

	# Search Query Construction
	$query_search = "db=$database&term=".preg_replace('/\s+/', '+', $user_query)."&field=$field&retmax=$max_results&tool=$tool&email=$email&usehistory=$history";

	$feed_search = file_get_contents($base_url_search.$query_search); # get xml from search api

	preg_match('/<WebEnv>(\S+)<\/WebEnv>/', $feed_search, $webenv);
	preg_match('/<QueryKey>(\d+)<\/QueryKey>/', $feed_search, $query_key);

	# fetch parameters
	$webenv = $webenv[1];
	$query_key = $query_key[1];
	$mode = 'xml';

	# fetch Query Construction
	$query_fetch = "db=$database&query_key=$query_key&query_key=$query_key&WebEnv=$webenv&retmode=$mode&retmax=$max_results&tool=$tool&email=$email";

	$feed_fetch = file_get_contents($base_url_fetch.$query_fetch); # get xml from fetch api

	# parse entries from whole xml
	preg_match_all('/<PubmedArticle>(.+?)<\/PubmedArticle>/is', $feed_fetch, $entries,PREG_UNMATCHED_AS_NULL);

	if(empty($entries)){
		return pubmed_entries;
	}

	foreach ($entries[1] as $entry) {
		$entry_count += 1;

		# parse each entry
		preg_match('/<PMID(.+?)\/PMID>/is', $entry, $id); # id
		preg_match('/>(.+?)</is', $id[1], $id);
		preg_match('/<Journal>(.+?)<\/Journal>/is', $entry, $journal_raw);
			preg_match('/<Title>(.+?)<\/Title>/is', $journal_raw[1], $journal); # journal
			preg_match('/<Year>(.+?)<\/Year>/is', $journal_raw[1], $year); # year

			preg_match('/<Month>(.+?)<\/Month>/is', $journal_raw[1], $month, PREG_UNMATCHED_AS_NULL); # month
			preg_match('/<Day>(.+?)<\/Day>/is', $journal_raw[1], $day, PREG_UNMATCHED_AS_NULL); # day

			if(empty($month)){$month = '';}else{$month = $month_ref[$month[1]];}
			if(empty($day)){$day = '';}else{$day = $day[1];}
			if(empty($year)){$year = '';}else{$year = $year[1];}

			$publish_date = $day.'/'.$month.'/'.$year; # date of publish

		preg_match('/<ArticleTitle>(.+?)<\/ArticleTitle>/is', $entry, $title); # title
		preg_match_all('/<AbstractText(.+?)<\/AbstractText>/is', $entry, $abstract_raw, PREG_UNMATCHED_AS_NULL); # abstract
		if(empty($abstract_raw)){
			$abstract[1] = '';
		}
		else{
			$abstract = '';
			foreach ($abstract_raw[1] as $abstract_piece) {
				preg_match('/>(.*)/is', $abstract_piece, $text);
				preg_match('/Label="(.+?)"/is', $abstract_piece, $label, PREG_UNMATCHED_AS_NULL);
				if (empty($label)) {
					$abstract.=$text[1]."\n";
				}else{
					$abstract.='<b>'.$label[1].':</b>'.$text[1]."\n";
				}
			}

		}

		preg_match_all('/<Author(.+?)<\/Author>/is', $entry, $authors_raw); # authors

			$authors = array();
			foreach ($authors_raw[1] as $author_raw) {
				preg_match('/<LastName>(.+?)<\/LastName>/is', $author_raw, $last_name, PREG_UNMATCHED_AS_NULL); # last name
				preg_match('/<ForeName>(.+?)<\/ForeName>/is', $author_raw, $fore_name, PREG_UNMATCHED_AS_NULL); # fore name
				if(empty($last_name) && empty($fore_name)){
					preg_match('/<CollectiveName>(.+?)<\/CollectiveName>/is', $author_raw, $col_name); # collective name exceptions
					$authors[] = $col_name[1];
				}elseif (empty($last_name)) {
					$authors[] = $fore_name[1];
				}elseif (empty($fore_name)) {
					$authors[] = $last_name[1];
				}else{
					$authors[] = $fore_name[1].' '.$last_name[1];
				}
			}

		preg_match('/<ArticleId IdType="doi">(.+?)<\/ArticleId>/is', $entry, $doi, PREG_UNMATCHED_AS_NULL); # doi
		if(empty($doi)){ $doi[1] = '';}

		preg_match_all('/<Keyword (.+?)<\/Keyword>/is', $entry, $keywords_raw, PREG_UNMATCHED_AS_NULL); # keywords
		if(empty($keywords_raw)){ 
			$keywords = '';
		}else{
			foreach ($keywords_raw[1] as $keyword_raw) {
				preg_match('/>(.*)/is', $keyword_raw, $keyword);
				$keywords[] = $keyword[1];
			}
		}

		# construct entry dict
		$entry = array( 
			'title' => $title[1],
			'link' => 'https://www.ncbi.nlm.nih.gov/pubmed/'.$id[1], 
			'doi' => $doi[1],
			'journal' => $journal[1],
			'publish date' => $publish_date,
			'abstract' => $abstract,
			'authors' => $authors,
			'keywords' => $keywords,
			'source' => 'pubmed',
			'source_id' => $id[1],
			);

		# append to entries dict
		$pubmed_entries["entry$entry_count"] = $entry;
	}
	print $base_url_fetch.$query_fetch;
	return $pubmed_entries;
}


#function test

#print "PUBMED RESULTS\n\n\n";

#$user_query = "Cancer";
#print_r(pubmed_search($user_query,"title"));

#print "ARXIV RESULTS\n\n\n";

#$user_query = "Quantum mechanics";
#print_r(arxiv_search($user_query,"ti"));

